Relative Ranking & Capital Priority Engine

(Non-Destructive, Additive Only)

CONTEXT (LOCK THIS IN)

You are extending Deep Dive Stock OS with Phase 2 intelligence.

Absolute Rules (Non-Negotiable)

‚ùå DO NOT modify Strategic or Tactical engines

‚ùå DO NOT change scores, thresholds, or gates

‚ùå DO NOT modify Market Context logic

‚ùå DO NOT modify UI yet

‚ùå DO NOT rename or move existing files

This prompt only adds a ranking engine that interprets existing outputs.

OBJECTIVE (ONE PURPOSE ONLY)

Create a Relative Ranking Engine that answers:

‚ÄúAmong acceptable stocks, which ones deserve capital priority?‚Äù

This engine:

Does not change scores

Does not change WATCH / REJECT / TRADE

Uses Phase-1 outputs + Phase-2 metadata

Produces BUY / ACCUMULATE / PILOT / WATCH / BLOCKED

FILES TO CREATE (ONLY THESE)
1Ô∏è‚É£ Relative ranking engine
server/domain/ranking/relativeRankingEngine.ts

2Ô∏è‚É£ Ranking types
shared/types/ranking.ts


‚ùå Do not modify any existing files.

TYPE DEFINITIONS (EXACT)
üìç shared/types/ranking.ts

Create:

export type CapitalPriority =
  | "BUY"
  | "ACCUMULATE"
  | "PILOT"
  | "WATCH"
  | "BLOCKED";

export interface RankedStock {
  symbol: string;
  sector: string;
  strategicScore: number;
  tacticalScore: number;
  strategicStatus: "ELIGIBLE" | "WATCH" | "REJECT";
  tacticalStatus: "TRADE" | "WATCH" | "AVOID";
  sectorRegime: "FAVORED" | "NEUTRAL" | "AVOID";
  portfolioAction: "ALLOW" | "REDUCE" | "BLOCK";
  rankInSector: number;
  capitalPriority: CapitalPriority;
  reasons: string[];
}

RELATIVE RANKING ENGINE LOGIC
üìç server/domain/ranking/relativeRankingEngine.ts

Create the following pure function:

import { RankedStock, CapitalPriority } from "@shared/types/ranking";

interface RankingInput {
  symbol: string;
  sector: string;
  strategicScore: number;
  tacticalScore: number;
  strategicStatus: "ELIGIBLE" | "WATCH" | "REJECT";
  tacticalStatus: "TRADE" | "WATCH" | "AVOID";
  sectorRegime: "FAVORED" | "NEUTRAL" | "AVOID";
  portfolioAction: "ALLOW" | "REDUCE" | "BLOCK";
}

export function rankStocks(
  stocks: RankingInput[]
): RankedStock[] {
  // Group by sector
  const bySector: Record<string, RankingInput[]> = {};
  for (const stock of stocks) {
    bySector[stock.sector] ??= [];
    bySector[stock.sector].push(stock);
  }

  const ranked: RankedStock[] = [];

  for (const sector of Object.keys(bySector)) {
    const sectorStocks = bySector[sector]
      .filter(s => s.strategicStatus !== "REJECT")
      .sort((a, b) => b.strategicScore - a.strategicScore);

    sectorStocks.forEach((stock, index) => {
      const rankInSector = index + 1;
      const reasons: string[] = [];

      let capitalPriority: CapitalPriority = "WATCH";

      // Hard blocks
      if (
        stock.portfolioAction === "BLOCK" ||
        stock.sectorRegime === "AVOID"
      ) {
        capitalPriority = "BLOCKED";
        reasons.push("Capital blocked by portfolio or sector regime");
      }
      // Tactical opportunity
      else if (
        stock.tacticalStatus === "TRADE" &&
        stock.portfolioAction === "ALLOW"
      ) {
        capitalPriority = "BUY";
        reasons.push("Active tactical opportunity with capital available");
      }
      // Strategic accumulation
      else if (
        stock.strategicStatus === "ELIGIBLE" &&
        stock.sectorRegime === "FAVORED" &&
        rankInSector <= 2
      ) {
        capitalPriority = "ACCUMULATE";
        reasons.push("Top-ranked stock in favored sector");
      }
      // Early pilot position
      else if (
        stock.strategicStatus === "WATCH" &&
        stock.sectorRegime !== "AVOID" &&
        rankInSector === 1
      ) {
        capitalPriority = "PILOT";
        reasons.push("Best-in-sector watch candidate");
      }

      ranked.push({
        ...stock,
        rankInSector,
        capitalPriority,
        reasons,
      });
    });
  }

  return ranked;
}

IMPORTANT DESIGN NOTES (READ THIS)
Why this works

Scores stay untouched

WATCH ‚â† equal anymore

Sector + portfolio context decides priority

BUYs appear only when justified

Why this is safe

No logic is overridden

No signal inflation

All upgrades are explainable

VALIDATION CHECKLIST

After running this prompt:

App builds and runs

No change in Strategic / Tactical scores

No change in UI yet

You can call rankStocks() with mock inputs

Output includes:

rankInSector

capitalPriority

Human-readable reasons

If anything else changes, stop.

END OF PROMPT